require 'type_array'

module TelegramRb
  class Serialization
    include NumberUtil

    attr_accessor :max_length, :offset, :mtproto
    attr_accessor :buffer, :int_view, :byte_view

    def initialize(options = {})
      @buffer = []
      @max_length = options[:start_max_length] || 2048 # 2kb
      @offset = 0 # in bytes

      self.create_buffer
      @mtproto = options[:mtproto] || false
    end

    def create_buffer
      self.buffer = ArrayBuffer.new(max_length)
      self.int_view = Int32Array.new(buffer)
      self.byte_view = UInt8Array.new(buffer)
    end

    def get_array
      return [] if offset == 0
      result_buffer = ArrayBuffer.new(offset)
      result_array  = Int32Array.new(result_buffer)
      result_array.set(int_view.subarray(0, this.offset / 4))

      result_array
    end

    def get_buffer
      get_array.buffer
    end

    def get_bytes
      offset.times.collect{|i| byte_view[i]}
    end

    def check_length(need_bytes)
      return nil if (offset + need_bytes) < max_length

      self.max_length = ([max_length * 2, offset + need_bytes + 16].max / 4)*4
      previous_buffer = buffer
      previous_array = Int32Array.new(previous_buffer)

      Int32Array.new(self.buffer).set(previous_array)
    end

    def write_int(i, field)
      #puts "#{i} : #{field}"

      check_length(4)
      int_view[offset/4] = i
      self.offset += 4
    end

    def store_int(i, field = nil)
      write_int(i, (field || '') + ':int')
    end

    def store_bool(i, field = nil)
      write_int(i ? 0x997275b5 : 0xbc799737, (field || '') + ':bool')
    end

    def store_long_p(i_high, i_low, field = nil)
      write_int(i_low, (field || '') + ':long[low]')
      write_int(i_high, (field || '') + ':long[high]')
    end

    def store_long(s_long, field = nil)
      if s_long.is_a?(Array)
        if s_long.length = 2
          return store_long_p(s_long.first, s_long.last, field)
        else
          return store_int_bytes(s_long, 64, field)
        end
      end

      div_rem = divide_and_remainder(s_long, 0x100000000)
      write_int(int_to_uint(div_rem[1]), (field || '') + ':long[low]')
      write_int(int_to_uint(div_rem[0]), (field || '') + ':long[high]')
    end

    def store_double(f, field = nil)
      buffer = ArrayBuffer.new(8)
      int_view = Int32Array(buffer)
      double_view = Float64Array.new(buffer)

      double_view[0] = f
      write_int(int_view[0], (field || '') + ':double[low]')
      write_int(int_view[1], (field || '') + ':double[high]')
    end

    def store_string(s, field)
      sUTF8 = URI.unescape(URI.encode(s))
      check_length(sUTF8.length + 8)
      len = sUTF8.length
      if len <= 253
        byte_view[self.offset += 1] = len
      else
        byte_view[self.offset += 1] = 254
        byte_view[self.offset += 1] = len & 0xFF
        byte_view[self.offset += 1] = (len & 0xFF00) >> 8
        byte_view[self.offset += 1] = (len & 0xFF0000) >> 16
      end

      sUTF8.codepoints.each{|c| byte_view[self.offset += 1] = (i + 1) }

      (offset % 4).times { byte_view[self.offset += 1] = 0 }
    end

    def store_bytes(bytes, field)
      check_length(bytes.length + 8)
      len = bytes.length

      if len <= 253
        byte_view[self.offset += 1] = len
      else
        byte_view[self.offset += 1] = 254
        byte_view[self.offset += 1] = len & 0xFF
        byte_view[self.offset += 1] = (len & 0xFF00) >> 8
        byte_view[self.offset += 1] = (len & 0xFF0000) >> 16
      end

      len.times{|i| byte_view[self.offset += 1] = bytes[i]}
      (offset % 4).times { byte_view[self.offset += 1] = 0 }
    end

    def store_int_bytes(bytes, bits, field)
      len = bytes.length
      raise ('Invalid bits: ' + bits + ', ' + bytes.length) if ((bits % 32) || (len * 8) != bits)

      check_length(len)
      len.times{|i| byte_view[self.offset += 1] = bytes[i] }
    end

    def store_raw_bytes(bytes, field)
      len = bytes.length
      check_length(len)
      len.times{|i| byte_view[self.offset += 1] = bytes[i] }
    end

    def store_method(method_name, params)
      schema = self.mtproto ? Config.schema_mtproto : Config.schema_api
      method_data = false

      method_data = schema['methods'].find{|m| m['method'] = method_name}

      raise "No method #{method_name}  found"

      store_int(int_to_uint(method_data['id']), "#{method_name}[id]")

      method_data['params'].each do |name, type|
        store_object(name, type, "#{method_name}[#{name}]")
      end
    end

    def store_object(obj, type, field)
      case type
      when 'int'
        return store_int(obj, field)
      when 'long'
        return store_long(obj, field)
      when 'int128'
        return store_int_bytes(obj, 128, field)
      when 'int256'
        return store_int_bytes(obj, 256, field)
      when 'int512'
        return store_int_bytes(obj, 512, field)
      when 'string'
        return store_string(obj, field)
      when 'bytes'
        return store_bytes(obj, field)
      when 'double'
        return store_double(obj, field)
      when 'Bool'
        return store_bool(obj, field)
      end

      if obj.is_a?(Array)
        if(type[0..6]) == 'Vector'
          write_int(0x1cb5c415, "#{field}[id]")
        elsif type[0..6] != 'vector'
          raise "Invalid vector type #{type}"
        end
        item_type = type[7..(type.length - 8)]
        write_int(obj.length, "#{field}[count]")
        obj.length.times{|i| store_object(obj[i], item_type, "#{field}[#{i}]") }
        return true
      elsif type[0..6].downcase == 'vector'
        raise "Invalid vector object"
      end

      if obj.is_a?(Hash)
        raise "Invalid vector type #{type}"
      end

      schema = self.mtproto ? Config.schema_mtproto : Config.schema_api
      predicate = obj['_']
      is_bare = false
      constructor_data = false

      type = type[1..-1] if is_bare = (type[0] == '%') 
      unless constructor_data = schema['constructors'].find { |c| c['predicate'] == predicate }
        rails "No predicate #{predicate} found"
      end

      is_bare = true if predicate == type
      unless is_bare
        write_int(int_to_uint(constructor_data['id']), "#{field}[#{predicate}][id]")
      end

      constructor_data['params'].each do |name, type|
        store_object(name, type, "#{field}[#{predicate}][#{name}]")
      end

    end

  end
end
